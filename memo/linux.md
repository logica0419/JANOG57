## Linux ネットワークの前提知識メモ

Linux ネットワークの全て。主要な概念と仕組みをまとめる。

- Linux のルーティング
  - (宛先プレフィックス, 次ホップ (ゲートウェイ), 出力インターフェース) の組で表現される
- syscall
  - `bind`: 4-tuple のローカル側の（IP, port）を固定する
  - `connect`: 相手側（IP, port）を固定し、経路探索と接続状態（TCPなら）を開始する
- 全体像
  - 仕組みは単純 (例: 受信の場合)
    - アプリはソケットで通信する (L4)
    - 送るには宛先IPが必要で、宛先IPはルーティングに入る (L3)
    - ルーティングの結果は次ホップIP＋出口IF (L3)
    - 次ホップIPをL2で渡すためにneighborでMACが要る (L2)
    - 最後にデバイス（NIC等）からフレームとして出る (L1)
  - ↑に対し、以下の概念が付加される
    - netfilterは「この鎖の途中に介入する」
    - NATは「IP/ポートと状態を途中で書き換える」
    - netlinkは「この鎖を構成する状態を作る／見る」
    - veth/bridge/tunは「出口IFやリンクそのものを増やす」
- ↑ただし、受信した全てのパケットがユーザーランドのアプリケーションに渡るわけではない (ルーターの概念)、それが以下
- 基本的にパケットが通る処理ラインは以下の3つ
  - 受信 (RX) 経路
    - データプレーン
      - L2: NICがフレームを受信し、MAC アドレスが自分宛てなら剥がして L3 へ
      - L3: 宛先IPを見て分岐する
        - 自分宛て（ローカル配送）なら L4 へ
        - 自分宛てではない（転送候補）
      - L4: 該当ソケット（ポート等）へ配送、ユーザーランドへ
    - コントロールプレーン
      - IF に設定された CIDR 等 (自分宛てか確認する時)
      - ルーティングテーブル (転送先を決定する時)
  - 転送 (FORWARD) 経路
    - 外から来たフレームを別のIFから外へ出す (ルーターとしての振る舞い)
    - データプレーン
      - (RX 経路で自分宛てではなかった場合)
      - 宛先IPが自分ではないと判断、L3 までの解釈にとどめる
      - L3: TTLを減らす (ルーター的)
      - L3: ルーティングテーブルで「出口IF＋次ホップIP」を決める
      - L2: MAC テーブルで「次ホップIP→MAC」を得る
      - L2ヘッダを作り直して出口IFから送信
    - 重要:
      - 次ホップに転送するので L2 ヘッダは必ず作り直される（入力IFのL2は捨てる）
      - 転送は L3 の判断で成立し、L2は次ホップへ渡す道具になる
  - 送信 (TX) 経路
    - データプレーン
      - ユーザーランドから `send`/`write`
      - L4: ソケットから L4 スタックへ
      - L3: ルーティングテーブルで「出口IF＋次ホップIP」を決める
      - (以降は FORWARD 経路と一緒、ルーティングテーブルと MAC テーブルを見てヘッダつけて適切な出口 IF から送信)
- Linux netfilter (主にデータプレーン)
  - パケットが通る上記の3経路（RX/TX/FORWARD）の途中に「フック」を置き、そこにルールを差し込めるようにした仕組み
  - フックは以下の5つ
    - PREROUTING（ルーティング決定の前、受信直後）
    - INPUT（ローカル配送が確定した後、ローカルに入る直前）
    - FORWARD（転送が確定した後、転送中）
    - OUTPUT（ローカル生成パケットが出ていく直前、ルーティングの後）
    - POSTROUTING（送信直前、実際にデバイスへ出す直前）
  - つまり、3経路において
    - 受信（RX: 外→自分）
      - NIC受信 → PREROUTING → ルーティング判定 → INPUT → L4配送 → ユーザーランド
    - 転送（FORWARD: 外→外）
      - NIC受信 → PREROUTING → ルーティング判定 → FORWARD → POSTROUTING → 送信
    - 送信（TX: 自分→外）
      - ユーザーランド → OUTPUT → ルーティング判定（この前後の扱いは実装上の詳細があるが、概念としてはここで出口が決まる）→ POSTROUTING → 送信
  - ![image](https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcShqdFyddo3N3AHYtd9PraxDoBgTUhcMNsrtQ)
  - 各フックで出来ることは大きく分けて以下の3つの操作
    - filter する
      - 条件を参照→通す/落とす/拒否するのどれかを行う
    - 書き換える
      - 例: NAT
    - 状態参照
      - conntrack
        - 複雑なので今は後で良い。キーから同一通信の往復を追跡する
        - キーは概ね4-tuple と方向 (original/reply)、場合により拡張
          - 活用先
            - 同じソケットの戻る方向のパケットを“同じ通信の返答”として認識
            - NATの逆変換
            - stateful firewall (ESTABLISHEDだけ許可など)
  - テーブル、チェイン、ルール
    - 包含関係: テーブル>チェイン>ルール列
    - テーブルは目的別 (iptables: filter, nat, mangle, raw, security)、チェインはその目的を用いるフックの場所別
      - ![image](https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcQG9fGgKiC9-MmTU8fGxQ1rStLR1iGSLofIMA&s)
    - 例えば NAT のためには OUTPUT, PREROUTING, POSTROUTING にそれぞれ処理を挟む (チェイン) 必要があるが、これをまとめたものを nat テーブルから一覧できる
  - テーブルの種類 (iptables の場合であることに注意。nftables では任意の名前の任意のテーブルを作成できる)
    - 基本的には filter, nat, mangle の3種類を理解していれば良い
    - filter
      - 通す/落とす（純粋なフィルタリング等）
      - INPUT / FORWARD / OUTPUT チェインを持つ
    - nat
      - アドレス/ポート変換（DNAT/SNAT等）
      - PREROUTING / OUTPUT / POSTROUTING チェインを持つ
    - mangle
      - パケット属性の細工（TOS/DSCP/TTL/mark等）
      - PREROUTING / INPUT / FORWARD / OUTPUT / POSTROUTING チェインを持つ (全て)
    - raw：conntrackへの介入
      - 高度なので今回は範囲外とする
    - security：MAC/SELinux等の追加制御（環境依存）
      - 高度なので今回は範囲外とする
    - ![image](https://thermalcircle.de/lib/exe/fetch.php?media=linux:nf-hooks-iptables1.png)
  - ルール
    - 各チェインのルールには既定動作（policy）がある
      - 大抵は ACCEPT か DROP が設定される
    - ルールにマッチした時の動作一覧
      - ACCEPT：通す（次段へ）
      - DROP：黙って捨てる
      - REJECT：拒否を通知して捨てる
      - RETURN：呼び出し元へ戻る
        - 高度なので今回は範囲外とする
  - conntrack
    - 人間が設定するものではなく、勝手にルールが作られて勝手にルールが消える
    - 主に NAT やポートフォワードのために、送受信のパケットがどの通信に対応しているかをマークするための一時的な記録帳
    - 穴あけ要員
    - 例えば
      - NAT が内から外に通信したは良いものの、外から中への対応はどうするか
        - 通信が始まる時を検出して、conntrack にキーとして保持しておく。後で返ってきたパケットが conntrack の記録を見て既存の通信に対応するかを調べる
      - firewall が外からの新規通信を遮断、既に ESTABLISHED である通信のみ許可 (外からも中からも通信 OK)
        - それぞれのパケットは独立しているが、同一の通信上であることを conntrack で見る
      - UDP hole punching
        - UDP は無状態であるはずなのに NAT traversal ができる本質部分
        - ただし TCP と違って状態で見ていないので、時間でアバウトに見ることになる
    - SNAT の例 (LAN 内サーバ↔WAN、Linux が間に挟まってルーターとして動作している例)
      - original方向 (内→外)
        - LAN側からフレーム受信（RX入口）
        - conntrackはこの時点で「新規フローっぽい」と判断し得る（UDP初回やTCP SYNなど）
        - ルーティング判定
        - 宛先は外部なので「転送（FORWARD）」になる。出口IFはWAN側に決まる
        - FORWARD（filter が用いられる）
          - LANからのNEWは許可、WANからのNEWは拒否、ESTABLISHED は許可等のルールを入れる。ESTABLISHED かどうかを判断できるのは conntrack のおかげ。
        - POSTROUTING（nat が用いられる）
          - ここで送信元を内側IP:port から 外側IP:port へ書き換える。同時に conntrack エントリに「このフローの翻訳対応」を記録する。これが戻る方向の時に利用される。
        - WAN側へ送信
      - reply 方向 (外→内)
        - 記録した conntrack を用いて逆向きに元に戻す (ESTABLISHED なので通過する)
      - 本質
        - 翻訳対応が conntrack に格納される
        - 外部から見ると「外側IP:port から来た通信」に見える
- netlink (コントロールプレーン)
  - 以下の状態オブジェクトを構成・操作するための制御盤
  - Linuxネットワークの状態オブジェクト
    - Link
      - インターフェースの事
      - 物理NIC、veth、bridge、tunなどを含む「出入口」の実体。ここがデータプレーンの入口/出口になる
    - Address
      - Linkにぶら下がるCIDR
      - netfilter (データプレーン) において、自分宛てかフォワードかなどの判断に使われる
    - Route
    - 宛先プレフィックス→次ホップ/出口IF の対応表
    - L3の FIB として参照される。いわゆるルーティングテーブル
    - Neighbor
    - 次ホップIP→MAC（ARP/NDPキャッシュ）の対応表
    - L3→L2境界の状態。いわゆる MAC テーブル (厳密にはそれのキャッシュ)
    - Rule/Policy
      - 高度なので今回は範囲外とする
    - Xfrm（IPsec系）や Tunnel系
      - 高度なので今回は範囲外とする
  - iproute2: netlink のフロントエンド
    - Linkを作る/消す/設定する（UP/DOWN、MTU等）、Addressを付ける/消す、Routeを付ける/消す等
    - ユーザ空間からカーネルへ「状態変更要求」を送るためのフロントエンド
  - つまり、Linuxネットワークは「状態オブジェクト（link/address/route/neighbor/policy）」を コントロールプレーン (netlink) で構成し、データプレーン（netfilter, RX/TX/FORWARD）がそれを参照して動く
- 仮想デバイス
  - Linuxの仮想ネットワークは「Linkを増やす」ことでネットワーク構造を作る
  - vethはリンクそのもの、bridgeはL2集合、VLANは論理分割、tun/tapはユーザ空間への注入口
  - 代表は以下の4つ
    - veth
      - 2つで1組の仮想的なケーブル
      - データプレーン
        - veth-A にフレームが入ると、即座に veth-B にフレームが出る
          - フレームの中身（L2/L3/L4）は基本的にそのまま
          - これは物理線でも一緒
      - コントロールプレーン
        - Linkが2つ増える（veth-A, veth-B）
        - それぞれに Address を付けられる（L3で使うなら）
        - それぞれはそれぞれの Route/Neighbor の参照点になれる
      - 用途
        - ネットワーク名前空間（netns）を繋ぐケーブル
    - bridge
      - カーネル内 L2 スイッチ
        - おさらい: bridge
          - 複数のLinkを束ねて、1つのL2ブロードキャストドメインを作る装置
      - データプレーン
        - bridgeに所属するポート（例：vethや物理NIC）でフレームを受信
        - 送信元MACを学習してFDBを更新、宛先MACをFDB参照して転送、未知ならフラッディング
        - L2 の普通のブリッジと同様
      - コントロールプレーン
        - bridge自身も Link として存在する（bridge0のようなもの）
        - bridgeに“ポートとして参加するLink”がぶら下がる
        - bridgeに Address を付けると「そのL2セグメント上のホスト」として振る舞える
      - 用途
        - ホスト内に仮想L2セグメントを作る
        - 複数のコンテナ/VMを同一L2に置く
        - 物理NICを混ぜれば外部L2へ延長できる
    - VLAN
      - タグ付きでL2を分割
      - VLAN:
        - 同じ物理線 (同じLink) を、複数の論理L2セグメントに分ける技術。分割のキーは VLAN ID (いわゆるタグ)
      - データプレーン
        - VLANタグ付きフレームは VLAN ID ごとに別セグメント扱いになる
        - ブロードキャストも VLAN 内に閉じる
      - コントロールプレーン
        - Linuxでは VLAN も「Linkとして増える」(そのように扱える)
        - 親Link（例：eth0）があり、その上に VLAN 100 の子Link（例：eth0.100）が生える
        - 子Linkに Address を付け、Route を持てる
        - 結果として、同じ物理NIC上に複数サブネットを載せられる
      - 用途
        - 1台のサーバで複数L2セグメントを扱う
        - データセンタでのネットワーク分離
        - 仮想化/コンテナでのテナント分離の基礎
    - tun/tap
      - ユーザ空間がパケット/フレームを読み書きできるLinkを作る (ネットワーク処理のユーザーランドへの委譲)
      - tap（L2）
        - ユーザ空間がイーサネットフレームを読む/書く
        - bridge に繋げられる (L2の一員として振る舞える)
      - tun（L3）
        - ユーザ空間がIPパケットを読む/書く
        - L2を持たず、より純粋にL3として扱う
      - データプレーン
        - カーネル↔ユーザ空間の間でパケットが出入りする
        - ユーザ空間側が暗号化/カプセル化/ルーティングのような処理をして戻す
        - つまり tun/tap はネットワーク機能をユーザ空間に持ち出す装置
      - コントロールプレーン
        - tun/tapも Link であり、Address/Route/Neighborの参照点になる
      - 用途
        - VPN
          - つまりカーネルからするとVPNは特殊機構ではなく、Linkを1本増やして経路をそちらへ向けるだけという見え方になる
- VPN
  - 内側のIPパケット（inner）を、そのまま別のIPパケット（outer）のペイロードとして運ぶ
    - これにより、本来は直接届かないネットワークを別のネットワーク越しにあたかも直結のように扱える
    - inner：本当に届けたい相手へのパケット
      - 仮想的な IP (L3 VPN) や MAC アドレス (L2 VPN)
    - outer：それを運ぶための搬送用パケット（トンネル終端間の通信）
      - 物理的な、普通の IP や MAC アドレス
    - LinuxでVPNを組むと大抵 tun/tap や tunnel device が生える (トンネル IF)
    - アプリや上位は普通のネットワークIFに送っているだけ
    - データプレーン (TX の例)
      - アプリ → socket → L4 → IP(=inner) → route（トンネルIFへ）→ tunnel処理 → IP(=outer) → route（物理IFへ）→ NIC
    - ↑つまり、ルーティングは2回ある
      - netfilter の視点: ここに NAT も挟まると、フィルタ/変換の対象も2層ある
  - 大まかな分類
    - L3 VPN（innerがIP）
      - tunデバイスが典型
      - ルーティングで流す
      - 設計が比較的単純（L2の問題を引きずらない）
    - L2 VPN（innerがEthernet）
      - tap + bridge、あるいは VXLAN 等のL2 overlay
      - ブロードキャストやARPもトンネル越しに運ぶ
      - 挙動は強いが、L2スケール問題がついてくる (L2 はスケールしにくい問題が再来する)
- XDP/eBPF (簡易的な説明、詳細な説明は後に回す)
  - カーネル内のネットワーク処理のかなり早い段階に組み込まれる
  - できること
    - DROP（捨てる）
    - PASS（通常のスタックへ渡す）
    - REDIRECT（別IFへ回す）
    - TX（同じIFから返す）
  - ![image](https://upload.wikimedia.org/wikipedia/commons/3/37/Netfilter-packet-flow.svg)
- netns
  - ネットワークスタックの状態オブジェクトを分離する機構
    - 分離されるもの: Link, Address, Route, Neighbor (そのnsのARP/NDPキャッシュ等も), ソケット (nsが違えば同じportを別プロセスが使える) など
    - つまり、1台のLinuxの中に複数の“独立したホスト”を作る
  - 最小のコンテナネットワークの基礎の例
    - 部品
      - ホストnsに bridge（例：br0）
      - コンテナnsに veth片側（例：vethC）
      - ホストnsに vethもう片側（例：vethH）をbr0へ接続
      - コンテナnsのvethCにIPアドレス（例：10.0.0.2/24）
      - br0にIPアドレス（例：10.0.0.1/24）＝コンテナのデフォルトゲートウェイ相当
      - コンテナnsのルート：default via 10.0.0.1
      - ホストnsでNAT（SNAT/MASQUERADE）を外向きIFに対して設定
  - データプレーンで追う（内→外）
    - 1. コンテナ内：TX
      - アプリ → socket → L4 → IP → route（defaultでvethCへ）→ L2 → vethC
    - 2. veth：ケーブル
      - vethCに入ったフレームが vethHへ出る
    - 3. ホストns：RX→（自分宛てではないので）FORWARD
      - vethHで受信 → bridge（L2スイッチ） → 必要ならL3へ → ルーティング判定で外向きIFへ
    - 4. ホストns：POSTROUTINGでSNAT
      - 外へ出す直前に送信元を外側IPへ変換し、conntrackに対応を記録
    - 5. 外部へ送信
    - 返答はその逆 (外から返ってきたパケットがPREROUTINGでconntrack参照→逆変換→FORWARDでコンテナ側へ戻る)
  - コントロールプレーンで見る
    - 全て状態オブジェクトの構成
      - netns作成：新しい“ホスト”の箱を作る
    - 　veth作成：箱同士を結ぶケーブルを作る
    - 　bridge作成：ホスト側にL2セグメントを作る
    - 　Address/Route設定：L3到達性を作る
    - 　netfilter/NAT設定：外部との境界変換と穴あけを作る
    - そして、これらの状態操作の裏には netlink (iproute2) がいる
